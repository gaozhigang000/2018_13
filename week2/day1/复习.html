<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
</body>
</html>
<script>
    //  变量提升 
    //  var  function 
    //  代码执行之前 要先去把代码中用var 和 function 声明的变量
    //  先变量提升一下； 用var的 变量 只声明不定义；
    //  function 声明的既声明又定义；（{}的外边）；

    //  let  const 不能重复声明；没有变量提升；
    //  let 可以重新赋值 
    //  const 不可以重新赋值
    //  for ;  for in ;   if ; switch ; while ; 
    //  针对 let const 有块级作用域
    //

    // 堆内存 栈内存
    // 作用域 栈内存（用来提供代码运行环境的）；
    // 全局作用域 
    // 全局变量 在全局声明（var function let const）的变量；
    // 私有作用域
    // 私有变量 形参，在私有作用域声明的变量；

    // 函数执行的过程：
    // 先开辟一个私有作用域，形参赋值，变量提升，代码执行；

    // 作用域销毁 
    // 立即销毁：函数执行完成之后，返回的内容（引用数据类型）没被占用；
    // 不立即销毁：返回的内容（引用数据类型）暂时被占用
    // 不销毁： 返回的内容（引用数据类型）被占用


    // 作用域链：
    // 变量的查找机制；私有作用域中有个变量，先看是否是私有的，不是的话，
    // 向上级作用域（看执行的函数在哪个作用域定义的）查找，一直查找到全局；

    // this
    // 函数执行的this ; 看点，没点一般都是window(非严格模式);
    // window中的this 是 window
    // DOM事件的绑定， this 帮定的DOM元素； 

    // 闭包
    // 私有变量的保护机制，保护私有变量不受外界干扰；
    // 一个不销毁的作用域
    function f3() {
        var a = 12;
        function f() {
            console.log(a)
        }
        return f;
    }
    var f4 = f3();





    // 1>2? let qqq = 13:let www=33; 不能写声明关键字 和 return

    // let a = 12;
    // var a = 10;
    function fn(){
        console.log(a);// a is not  defined
        let a = 12;
    }
    function a() {
        
    }
    // fn();

    var a = 2;
    function f1() {
        var a = 1;
        return function () {
            console.log(a)
        }
    }
    // f1();// f1作用域 立即销毁
    // f1()();// f1作用域 不立即销毁
    var f2 = f1();//f1作用域 不销毁 
    f2();
</script>